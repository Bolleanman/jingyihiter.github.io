<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.15" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
    <link rel='stylesheet' href='//fonts.googleapis.com/css?family=Open+Sans|Marcellus+SC'>
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/solarized_dark.min.css">
    <link rel="stylesheet" href="http://jingyihiter.github.io/css/styles.css">
    <link rel="stylesheet" href="http://jingyihiter.github.io/css/custom.css">
    <link rel="alternate" type="application/rss+xml" title="RSS" href="http://jingyihiter.github.io//index.xml">

    
    <title>my first blog - jingyihiter 博客</title>
    <meta property='og:title' content="my first blog - jingyihiter 博客">
    <meta property="og:type" content="article">
    

    <meta property="og:url" content="http://jingyihiter.github.io/post/first/">
    
    

  </head>

  <body>

    <header class="site">
      <nav class="navbar navbar-default">
        <div class="container">
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="http://jingyihiter.github.io/">jingyihiter 博客</a>
          </div>

          <div id="navbar" class="collapse navbar-collapse">
            
            <ul class="nav navbar-nav navbar-right">
              
              
              <li><a href="http://jingyihiter.github.io/about/">about me</a></li>
              
              
              
              <li><a href="http://jingyihiter.github.io/contact/">contact</a></li>
              
              
            </ul>
            
          </div>

        </div>
      </nav>
    </header>

    <div class="site">
      <div class="container">



<div class="single">

  <div class="row">
    <div class="col-md-8">

      <article class="single" itemscope="itemscope" itemtype="http://schema.org/Article">

        <meta itemprop="mainEntityOfPage"  itemType="https://schema.org/WebPage" content="http://jingyihiter.github.io/"/>
        <meta itemprop="dateModified" content="2016-05-15T21:38:16&#43;08:00">
        <meta itemprop="headline" content="my first blog">
        <meta itemprop="description" content="my first blog view code #include &lt;stdio.h&gt; #include &lt;Windows.h&gt; #include &lt;process.h&gt; #include &lt;string.h&gt; #include &lt;tchar.h&gt; #pragma comment(lib,&quot;Ws2_32.lib&quot;) #define MAXSIZE 65507 //发送数据报文的最大长度 #define HTTP_PORT 80 //http服务器端口 //Http 重要头部数据 struct HttpHeader{ char method[4]; // POST或者GET，注意有些伪CONNECT，本实验暂不考虑 char url[1024]; // 请求的url char host[1024]; // 目标主机 char cookie[1024 * 10]; //cookie HttpHeader(){ ZeroMemory(this, sizeof(HttpHeader)); } }; // HttpCache 缓存中的数据 struct HttpCache{ char url[1024]; char host[1024]; char last_modified[200]; char status[4]; char buffer[MAXSIZE]; HttpCache(){ ZeroMemory(this, sizeof(HttpCache)); } }; //cache中使用到的参数 HttpCache Cache[1024]; int cached_number = 0;//已经缓存的url数 int last_cache = 0;//上一次缓存的索引 //代理相关参数 SOCKET ProxyServer; sockaddr_in ProxyServerAddr; const int ProxyPort = 12345; //网站过滤用到的参数 char acl[1024][1024];//访问控制表 int acl_number = 0;//已经过滤的网站数 //用户过滤用到的参数 char doa_ip[1024][17];//禁止访问的用户的IP,deny of access int ip_number = 0;//已经禁止的用户数 //钓鱼网站用到的网页 char fishing_host[1024][1024];//钓鱼的网站，都重定向到today.hit.edu.cn int host_number = 0; //钓鱼的网站数 //由于新的连接都使用新线程进行处理，对线程的频繁的创建和销毁特别浪费资源 //可以使用线程池技术提高服务器效率 //const int ProxyThreadMaxNum = 20; //HANDLE ProxyThreadHandle[ProxyThreadMaxNum] = {0}; //DWORD ProxyThreadDW[ProxyThreadMaxNum] = {0}; struct ProxyParam{ SOCKET clientSocket; SOCKET serverSocket; }; bool InitSocket(); int ParseHttpHead(char *buffer, HttpHeader *httpHeader); bool ConnectToServer(SOCKET *serverSocket, char *host); unsigned int __stdcall ProxyThread(LPVOID lpParameter); void ParseCache(char *buffer, char *status, char* last_modified); int _tmain(int argc, _TCHAR* argv[]){ printf(&quot;代理服务器正在启动\n&quot;); printf(&quot;初始化...\n&quot;); if (!InitSocket()){ printf(&quot;socket 初始化失败\n&quot;); return -1; } printf(&quot;代理服务器正在运行，监听端口 %d\n&quot;, ProxyPort); SOCKET acceptSocket = INVALID_SOCKET; SOCKADDR_IN acceptAddr; ProxyParam *lpProxyParam; HANDLE hThread; DWORD dwThreadID; char user_ip[16]; //代理服务器不断监听 while (true){ acceptSocket = accept(ProxyServer, (sockaddr*)&amp;acceptAddr, NULL);//在代理服务器上创建新的socket(acceptSocket)与客户通信 printf(&quot;用户的IP：%s\n&quot;, inet_ntoa(acceptAddr.sin_addr)); memcpy(user_ip, inet_ntoa(acceptAddr.sin_addr), 16); //用户过滤 for (int i = 0; i &lt; ip_number; i&#43;&#43;){ if (strcmp(user_ip, doa_ip[i]) == 0){ printf(&quot;用户:%s被禁止访问\n&quot;, user_ip); printf(&quot;套接字关闭\n&quot;); closesocket(acceptSocket); continue; } } lpProxyParam = new ProxyParam; if (lpProxyParam == NULL){ continue; } lpProxyParam-&gt;clientSocket = acceptSocket;//acceptSocket作为与客户端连接的socket hThread = (HANDLE)_beginthreadex(NULL, 0, &amp;ProxyThread, (LPVOID)lpProxyParam, 0, 0); //不调用CloseHandle的话会造成内存泄漏 CloseHandle(hThread); Sleep(200); } closesocket(ProxyServer); WSACleanup(); return 0; } //************************************ // Method: InitSocket // FullName: InitSocket // Access: public // Returns: BOOL // Qualifier: 初始化套接字 //************************************ bool InitSocket(){ //加载套接字库（必须） WORD wVersionRequested; WSADATA wsaData; //套接字加载时错误提示 int err; //版本 2.2 wVersionRequested = MAKEWORD(2, 2); //加载 dll 文件 Scoket 库,第一个参数是请求的Socket版本，第二个参数返回请求的Socket的版本信息。 //第一个参数的高位字节指明副版本、低位字节指明主版本 //当一个应用程序调用WSAStartup函数时，操作系统根据请求的Socket版本来搜索相应的Socket库， //然后绑定找到的Socket库到该应用程序中。 //以后应用程序就可以调用所请求的Socket库中的其它Socket函数了。 err = WSAStartup(wVersionRequested, &amp;wsaData); if (err != 0){ //找不到 winsock.dll printf(&quot;加载 winsock 失败，错误代码为: %d\n&quot;, WSAGetLastError()); return FALSE; } //高位字节指明副版本、低位字节指明主版本 if (LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 2) { printf(&quot;不能找到正确的 winsock 版本\n&quot;); WSACleanup();//终止Winsock 2 DLL (Ws2_32.dll)的使用.">
        <meta itemprop="url" content="http://jingyihiter.github.io/post/first/">
        <div itemprop="image" itemscope itemtype="https://schema.org/ImageObject">
          <meta itemprop="url" content="http://jingyihiter.github.io/images/default.jpg" />
          <meta itemprop="width" content="800">
          <meta itemprop="height" content="800">
        </div>
        <div itemprop="publisher" itemscope itemtype="https://schema.org/Organization">
          <div itemprop="logo" itemscope itemtype="https://schema.org/ImageObject">
            <meta itemprop="url" content="http://jingyihiter.github.io/images/logo.jpg">
            <meta itemprop="width" content="100">
            <meta itemprop="height" content="100">
          </div>
          <meta itemprop="name" content="jingyihiter 博客">
        </div>
        <div itemprop="author" itemscope itemtype="https://schema.org/Person">
          <meta itemprop="name" content="">
        </div>

        <header class="article-header">
          <time itemprop="datePublished" pubdate="pubdate" datetime="2016-05-15T21:38:16&#43;08:00">Sun, May 15, 2016</time>
          <h1 class="article-title">my first blog</h1>
        </header>

        <div class="article-body" itemprop="articleBody">
          

<h1 id="my-first-blog:e8fb9c67eba912c72729806db31eaa1b">my first blog</h1>

<p><img src="..imagesdog.png" alt="" /></p>

<h2 id="view-code:e8fb9c67eba912c72729806db31eaa1b">view code</h2>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;Windows.h&gt;
#include &lt;process.h&gt;
#include &lt;string.h&gt;
#include &lt;tchar.h&gt;

#pragma comment(lib,&quot;Ws2_32.lib&quot;)
#define MAXSIZE 65507 //发送数据报文的最大长度
#define HTTP_PORT 80 //http服务器端口

//Http 重要头部数据
struct HttpHeader{
    char method[4]; // POST或者GET，注意有些伪CONNECT，本实验暂不考虑
    char url[1024]; // 请求的url
    char host[1024]; // 目标主机
    char cookie[1024 * 10]; //cookie
    HttpHeader(){
        ZeroMemory(this, sizeof(HttpHeader));
    }
};

// HttpCache 缓存中的数据
struct HttpCache{
    char url[1024];
    char host[1024];
    char last_modified[200];
    char status[4];
    char buffer[MAXSIZE];
    HttpCache(){
        ZeroMemory(this, sizeof(HttpCache));
    }
};

//cache中使用到的参数
HttpCache Cache[1024];
int cached_number = 0;//已经缓存的url数
int last_cache = 0;//上一次缓存的索引

//代理相关参数
SOCKET ProxyServer;
sockaddr_in ProxyServerAddr;
const int ProxyPort = 12345;

//网站过滤用到的参数
char acl[1024][1024];//访问控制表
int acl_number = 0;//已经过滤的网站数

//用户过滤用到的参数
char doa_ip[1024][17];//禁止访问的用户的IP,deny of access
int ip_number = 0;//已经禁止的用户数

//钓鱼网站用到的网页
char fishing_host[1024][1024];//钓鱼的网站，都重定向到today.hit.edu.cn
int host_number = 0; //钓鱼的网站数

//由于新的连接都使用新线程进行处理，对线程的频繁的创建和销毁特别浪费资源
//可以使用线程池技术提高服务器效率
//const int ProxyThreadMaxNum = 20;
//HANDLE ProxyThreadHandle[ProxyThreadMaxNum] = {0};
//DWORD ProxyThreadDW[ProxyThreadMaxNum] = {0};
struct ProxyParam{
    SOCKET clientSocket;
    SOCKET serverSocket;
};

bool InitSocket();
int ParseHttpHead(char *buffer, HttpHeader *httpHeader);
bool ConnectToServer(SOCKET *serverSocket, char *host);
unsigned int __stdcall ProxyThread(LPVOID lpParameter);
void ParseCache(char *buffer, char *status, char* last_modified);

int _tmain(int argc, _TCHAR* argv[]){
    printf(&quot;代理服务器正在启动\n&quot;);
    printf(&quot;初始化...\n&quot;);
    if (!InitSocket()){
        printf(&quot;socket 初始化失败\n&quot;);
        return -1;
    }
    printf(&quot;代理服务器正在运行，监听端口 %d\n&quot;, ProxyPort);
    SOCKET acceptSocket = INVALID_SOCKET;
    SOCKADDR_IN acceptAddr;
    ProxyParam *lpProxyParam;
    HANDLE hThread;
    DWORD dwThreadID;
    char user_ip[16];
    //代理服务器不断监听
    while (true){
        acceptSocket = accept(ProxyServer, (sockaddr*)&amp;acceptAddr, NULL);//在代理服务器上创建新的socket(acceptSocket)与客户通信
        printf(&quot;用户的IP：%s\n&quot;, inet_ntoa(acceptAddr.sin_addr));
        memcpy(user_ip, inet_ntoa(acceptAddr.sin_addr), 16);

        //用户过滤
        for (int i = 0; i &lt; ip_number; i++){
            if (strcmp(user_ip, doa_ip[i]) == 0){
                printf(&quot;用户:%s被禁止访问\n&quot;, user_ip);
                printf(&quot;套接字关闭\n&quot;);
                closesocket(acceptSocket);
                continue;
            }
        }

        lpProxyParam = new ProxyParam;
        if (lpProxyParam == NULL){
            continue;
        }
        lpProxyParam-&gt;clientSocket = acceptSocket;//acceptSocket作为与客户端连接的socket
        hThread = (HANDLE)_beginthreadex(NULL, 0, &amp;ProxyThread, (LPVOID)lpProxyParam, 0, 0);
        //不调用CloseHandle的话会造成内存泄漏
        CloseHandle(hThread);
        Sleep(200);
    }
    closesocket(ProxyServer);
    WSACleanup();
    return 0;
}

//************************************
// Method:    InitSocket
// FullName:  InitSocket
// Access:    public
// Returns:   BOOL
// Qualifier: 初始化套接字
//************************************
bool InitSocket(){
    //加载套接字库（必须）
    WORD wVersionRequested;
    WSADATA wsaData;
    //套接字加载时错误提示
    int err;
    //版本 2.2
    wVersionRequested = MAKEWORD(2, 2);
    //加载 dll 文件 Scoket 库,第一个参数是请求的Socket版本，第二个参数返回请求的Socket的版本信息。
    //第一个参数的高位字节指明副版本、低位字节指明主版本
    //当一个应用程序调用WSAStartup函数时，操作系统根据请求的Socket版本来搜索相应的Socket库，
    //然后绑定找到的Socket库到该应用程序中。
    //以后应用程序就可以调用所请求的Socket库中的其它Socket函数了。
    err = WSAStartup(wVersionRequested, &amp;wsaData);
    if (err != 0){
        //找不到 winsock.dll
        printf(&quot;加载 winsock 失败，错误代码为: %d\n&quot;, WSAGetLastError());
        return FALSE;
    }
    //高位字节指明副版本、低位字节指明主版本
    if (LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 2) {
        printf(&quot;不能找到正确的 winsock 版本\n&quot;);
        WSACleanup();//终止Winsock 2 DLL (Ws2_32.dll)的使用.
        return false;
    }
    //在windows中的Winsock2.h中，
    //#define AF_INET 0
    //#define PF_INET AF_INET
    //所以在windows中AF_INET与PF_INET完全一样.
    //socket函数用于创建socket
    /**/
    //问题1：ProxyServer这个socket是创建在哪的？
    //创建在本地的
    /**/
    ProxyServer = socket(AF_INET, SOCK_STREAM, 0);
    if (INVALID_SOCKET == ProxyServer) {
        printf(&quot;创建套接字失败，错误代码为: %d\n&quot;, WSAGetLastError());
        return false;
    }
    ProxyServerAddr.sin_family = AF_INET;//地址族
    ProxyServerAddr.sin_port = htons(ProxyPort);//端口号，htons:本地字节顺序-&gt;网络字节顺序16bits
    //sin_addr的结构是in_addr
    //struct in_addr
    //{
    //  union
    //  {
    //      struct
    //      {
    //          u_char s_b1, s_b2, s_b3, s_b4;
    //      } S_un_b; //An IPv4 address formatted as four u_chars.
    //      struct
    //      {
    //          u_short s_w1, s_w2;
    //      } S_un_w; //An IPv4 address formatted as two u_shorts
    //      u_long S_addr;//An IPv4 address formatted as a u_long
    //  } S_un;
    //  #define s_addr S_un.S_addr
    //};
    ProxyServerAddr.sin_addr.S_un.S_addr = INADDR_ANY;
    //注意第二个参数的强制转换
    if (bind(ProxyServer, (SOCKADDR*)&amp;ProxyServerAddr, sizeof(SOCKADDR)) == SOCKET_ERROR) {
        printf(&quot;绑定套接字失败\n&quot;);
        return false;
    }
    //SOMAXCONN是最大连接个数，如果设置为 SOMAXCONN，套接字 s 的底层服务提供者将设置 backlog 为最大合理值。
    if (listen(ProxyServer, SOMAXCONN) == SOCKET_ERROR) {
        printf(&quot;监听端口%d 失败&quot;, ProxyPort);
        return false;
    }
    //初始化ACL
    //memcpy(acl[acl_number++], &quot;today.hit.edu.cn&quot;, 17);

    //初始化禁止的用户
    //memcpy(doa_ip[ip_number++], &quot;204.204.204.204&quot;, 16);

    //初始化引导网站
    memcpy(fishing_host[host_number++], &quot;www.sougou.com&quot;, 15);
    return true;
}

//*************************
//Method: ProxyThread
//FullName: ProxyThread
//Access: public
//Returns: unsigned int __stdcall
//Qualifier: 线程执行函数
//Parameter: LPVOID lpParameter
//*************************
unsigned int __stdcall ProxyThread(LPVOID lpParameter) {
    printf(&quot;正在执行代理的线程ID:%d\n&quot;, GetCurrentThreadId());
    char Buffer[MAXSIZE];
    char *CacheBuffer;
    ZeroMemory(Buffer, MAXSIZE);
    SOCKADDR_IN clientAddr;
    int length = sizeof(SOCKADDR_IN);
    int recvSize;
    int ret;

    //从客户端的socket处接受数据
    recvSize = recv(((ProxyParam*)lpParameter)-&gt;clientSocket, Buffer, MAXSIZE, 0);

    if (recvSize &lt;= 0) {
        goto error;
    }

    //解析HTTP报文头
    HttpHeader* httpHeader = new HttpHeader();
    CacheBuffer = new char[recvSize + 1];
    ZeroMemory(CacheBuffer, recvSize + 1);
    memcpy(CacheBuffer, Buffer, recvSize);
    int is_cached = ParseHttpHead(CacheBuffer, httpHeader);
    delete CacheBuffer;

    //执行网站过滤
    for (int i = 0; i &lt; acl_number; i++){
        if (strcmp(httpHeader-&gt;host, acl[i]) == 0){
            printf(&quot;线程ID:%d，禁止访问%s\n&quot;, GetCurrentThreadId(), httpHeader-&gt;host);
            goto error;
        }
    }

    //执行网站引导
    for (int i = 0; i &lt; host_number; i++){
        if (strcmp(httpHeader-&gt;host, fishing_host[i]) == 0){
            printf(&quot;线程ID:%d，网站%s已被重定向\n&quot;, GetCurrentThreadId(), httpHeader-&gt;host);
            //构造302的报文
            char fishing_buffer[MAXSIZE];
            ZeroMemory(fishing_buffer, MAXSIZE);
            char* pr;

            int fishing_len = strlen(&quot;HTTP/1.1 302 Moved Temporarily\r\n&quot;);
            memcpy(fishing_buffer, &quot;HTTP/1.1 302 Moved Temporarily\r\n&quot;, fishing_len);
            pr = fishing_buffer + fishing_len;

            fishing_len = strlen(&quot;Connection:keep-alive\r\n&quot;);
            memcpy(pr, &quot;Connection:keep-alive\r\n&quot;, fishing_len);
            pr = pr + fishing_len;

            fishing_len = strlen(&quot;Cache-Control:max-age=0\r\n&quot;);
            memcpy(pr, &quot;Cache-Control:max-age=0\r\n&quot;, fishing_len);
            pr = pr + fishing_len;

            fishing_len = strlen(&quot;Location: http://today.hit.edu.cn/\r\n\r\n&quot;);
            memcpy(pr, &quot;Location: http://today.hit.edu.cn/\r\n\r\n&quot;, fishing_len);

            //将302报文返回给客户端
            printf(&quot;线程ID:%d，代理正将302报文发送给客户端\n&quot;, GetCurrentThreadId());
            ret = send(((ProxyParam*)lpParameter)-&gt;clientSocket, fishing_buffer, sizeof(fishing_buffer), 0);
            goto error;
        }
    }

    //代理服务器去连接主机httpHeader-&gt;host，并把建立连接的socket保存到((ProxyParam*)lpParameter)-&gt;serverSocket
    if (!ConnectToServer(&amp;((ProxyParam*)lpParameter)-&gt;serverSocket, httpHeader-&gt;host)) {
        goto error;
    }
    printf(&quot;线程ID:%d，代理连接主机 %s 成功\n&quot;, GetCurrentThreadId(), httpHeader-&gt;host);

    //根据是否有缓存分成两种情况
    if (is_cached){//客户端请求的页面已经缓存
        printf(&quot;线程ID:%d, 正在向主机请求缓存\n&quot;, GetCurrentThreadId());
        char cached_buffer[MAXSIZE];
        ZeroMemory(cached_buffer, MAXSIZE);
        memcpy(cached_buffer, Buffer, recvSize);

        //构造缓存的报文头
        char* pr = cached_buffer + recvSize;
        memcpy(pr, &quot;If-modified-since: &quot;, 19);
        pr += 19;
        int lenth = strlen(Cache[last_cache].last_modified);
        memcpy(pr, Cache[last_cache].last_modified, lenth);
        pr += lenth;

        //将客户端发送的 HTTP 数据报文直接转发给目标服务器
        ret = send(((ProxyParam *)lpParameter)-&gt;serverSocket, cached_buffer, strlen(cached_buffer) + 1, 0);
        //等待目标服务器返回数据
        recvSize = recv(((ProxyParam *)lpParameter)-&gt;serverSocket, cached_buffer, MAXSIZE, 0);
        if (recvSize &lt;= 0) {
            goto error;
        }

        //解析包含缓存信息的HTTP报文头
        CacheBuffer = new char[recvSize + 1];
        ZeroMemory(CacheBuffer, recvSize + 1);
        memcpy(CacheBuffer, cached_buffer, recvSize);
        char last_status[4];//用于记录主机返回的状态字
        char last_modified[30];//用于记录记住返回的页面修改的时间
        ParseCache(CacheBuffer, last_status, last_modified);
        delete CacheBuffer;

        //分析cache的状态字
        if (strcmp(last_status, &quot;304&quot;) == 0){//没有被修改
            printf(&quot;线程ID:%d，页面没有修改过,缓存的url为:%s\n&quot;, GetCurrentThreadId(), Cache[last_cache].url);
            //将缓存的数据直接转发给客户端
            printf(&quot;线程ID:%d，代理正在转发数据\n&quot;, GetCurrentThreadId());
            ret = send(((ProxyParam*)lpParameter)-&gt;clientSocket, Cache[last_cache].buffer, sizeof(Cache[last_cache].buffer), 0);
        }
        else if (strcmp(last_status, &quot;200&quot;) == 0){//已经修改了
            //修改缓存中的内容
            printf(&quot;线程ID:%d，页面被修改过,缓存的url为:%s\n&quot;, GetCurrentThreadId(), Cache[last_cache].url);
            memcpy(Cache[last_cache].buffer, cached_buffer, strlen(cached_buffer));
            memcpy(Cache[last_cache].last_modified, last_modified, strlen(last_modified));

            //将目标服务器返回的数据直接转发给客户端
            printf(&quot;线程ID:%d，代理正在转发数据\n&quot;, GetCurrentThreadId());
            ret = send(((ProxyParam*)lpParameter)-&gt;clientSocket, cached_buffer, sizeof(cached_buffer), 0);
        }
    }
    else{//没有缓存过这个页面
        ret = send(((ProxyParam *)lpParameter)-&gt;serverSocket, Buffer, strlen(Buffer)+ 1, 0);
        //等待目标服务器返回数据
        recvSize = recv(((ProxyParam*)lpParameter)-&gt;serverSocket, Buffer, MAXSIZE, 0);

        memcpy(Cache[last_cache].buffer, Buffer, recvSize);//将页面的数据缓存
        printf(&quot;线程ID为：%d,正在缓存的url是：%s\n&quot;, GetCurrentThreadId(), Cache[last_cache].url);

        //将目标服务器返回的数据直接转发给客户端
        printf(&quot;线程ID:%d，代理正在转发数据\n&quot;, GetCurrentThreadId());
        ret = send(((ProxyParam*)lpParameter)-&gt;clientSocket, Buffer, sizeof(Buffer), 0);
    }
    //错误处理、完成转发
error:
    //问题2：为什么不是直接就把套接字关闭，而是将这个线程挂起？
    printf(&quot;线程ID为：%d结束，关闭套接字\n&quot;, GetCurrentThreadId());
    Sleep(200);
    closesocket(((ProxyParam*)lpParameter)-&gt;clientSocket);
    closesocket(((ProxyParam*)lpParameter)-&gt;serverSocket);
    delete lpParameter;
    //msdn上面说线程作为_beginthreadex参数传递的例程中返回时，会自动调用 _endthreadex
    //_endthreadex(0);
    return 0;
}

//*************************
//Method: ParseHttpHead
//FullName: ParseHttpHead
//Access: public
//Returns: void
//Qualifier: 解析 TCP 报文中的 HTTP 头部
//Parameter: char *buffer
//Parameter: HttpHeader *httpHeader
//*************************
int ParseHttpHead(char *buffer, HttpHeader *httpHeader) {
    int flag = 0;//用于表示Cache是否命中，命中为1，不命中为0
    printf(&quot;代理ID：%d, 正在解析Http的头部\n&quot;, GetCurrentThreadId());
    char *p;
    char *ptr;
    const char *delim = &quot;\r\n&quot;;//回车换行符
    //在第一次调用时，strtok_s()必需给予参数s字符串，往后的调用则将参数s设置成NULL。每次调用成功则返回指向被分割出片段的指针。
    p = strtok_s(buffer, delim, &amp;ptr);//提取第一行,strtok_s是分割字符串的函数，ptr中存储缓冲块中下一个将被读取的单词的位置
    printf(&quot;第一行：%s\n&quot;, p);

    if (p[0] == 'G') {  //GET方式
        memcpy(httpHeader-&gt;method, &quot;GET&quot;, 3);
        memcpy(httpHeader-&gt;url, &amp;p[4], strlen(p) - 13);//3(get)+8(http/1.1)+2(get后面和http前面的两个空格)
        printf(&quot;url：%s\n&quot;, httpHeader-&gt;url);//url
        //cache处理
        for (int i = 0; i &lt; 1024; i++){//搜索cache，看当前访问的url是否已经存在cache中了
            if (strcmp(Cache[i].url, httpHeader-&gt;url) == 0){//说明url在cache中已经存在
                flag = 1;
                break;
            }
        }
        if (!flag &amp;&amp; cached_number != 1023){//说明url没有在cache且cache没有满, 把这个url直接存进去
            memcpy(Cache[cached_number].url, &amp;p[4], strlen(p) - 13);//这个地方不加cached_number，在后面修改了host之后再加
            last_cache = cached_number;
        }
        else if (!flag &amp;&amp; cached_number == 1023){//说明url没有在cache且cache满了,把第一个cache覆盖
            memcpy(Cache[0].url, &amp;p[4], strlen(p) - 13);
            last_cache = 0;
        }
    }
    else if (p[0] == 'P') { //POST方式
        memcpy(httpHeader-&gt;method, &quot;POST&quot;, 4);
        memcpy(httpHeader-&gt;url, &amp;p[5], strlen(p) - 14);//4(post)+8(http/1.1)+2(post后面和http前面的两个空格)
        printf(&quot;url：%s\n&quot;, httpHeader-&gt;url);//url
        //cache处理
        for (int i = 0; i &lt; 1024; i++){
            if (strcmp(Cache[i].url, httpHeader-&gt;url) == 0){//说明url在cache中已经存在
                flag = 1;
                break;
            }
        }
        if (!flag &amp;&amp; cached_number != 1023){//说明url没有在cache且cache没有满, 把这个url直接存进去
            memcpy(Cache[cached_number].url, &amp;p[5], strlen(p) - 14);
            last_cache = cached_number;
        }
        else if (!flag &amp;&amp; cached_number == 1023){//说明url没有在cache且cache满了,把第一个cache覆盖
            memcpy(Cache[0].url, &amp;p[4], strlen(p) - 13);
            last_cache = 0;
        }
    }

    p = strtok_s(NULL, delim, &amp;ptr);//使用换行符分割，提取当前行
    while (p) {
        switch (p[0]) {
        case 'H'://HOST
            memcpy(httpHeader-&gt;host, &amp;p[6], strlen(p) - 6);//删除host: (这里有一个空格)，共6个字符
            if (!flag &amp;&amp; cached_number != 1023){//把host字段加入到cache中
                memcpy(Cache[last_cache].host, &amp;p[6], strlen(p) - 6);
                cached_number++;
            }
            else if (!flag &amp;&amp; cached_number == 1023){
                memcpy(Cache[last_cache].host, &amp;p[6], strlen(p) - 6);
            }
            break;
        case 'C'://Cookie
            if (strlen(p) &gt; 8) {
                char header[8];
                ZeroMemory(header, sizeof(header));
                memcpy(header, p, 6);
                if (!strcmp(header, &quot;Cookie&quot;)) {
                    memcpy(httpHeader-&gt;cookie, &amp;p[8], strlen(p) - 8);
                }
            }
            break;
        //case '':
        default:
            break;
        }
        p = strtok_s(NULL, delim, &amp;ptr);//使用换行符分割，提取当前行
    }
    return flag;
}

//*************************
//Method: ParseCache
//FullName: ParseCache
//Access: public
//Returns: void
//Qualifier: 解析 TCP 报文中的 HTTP 头部,在已经cache命中的时候使用
//Parameter: char *buffer
//Parameter: HttpHeader *httpHeader
//*************************
void ParseCache(char *buffer, char *status, char* last_modified){
    char *p;
    char *ptr;
    const char * delim = &quot;\r\n&quot;;
    p = strtok_s(buffer, delim, &amp;ptr);//提取第一行
    printf(&quot;缓存的第一行：%s\n&quot;, p);
    memcpy(status, &amp;p[9], 3);
    status[3] = '\0';
    p = strtok_s(NULL, delim, &amp;ptr);
    while (p){
        if (strstr(p, &quot;Last-Modified&quot;) != NULL){
            memcpy(last_modified, &amp;p[15], strlen(p) - 15);
            break;
        }
        p = strtok_s(NULL, delim, &amp;ptr);
    }
}

//**************************************
//Method:           ConnectToServer
//FullName:         ConnectToServer
//Access:           public
//Returns:          bool
//Qualifier:        根据主机创建目标服务器套接字，并连接
//Parameter:        SOCKET *serverSocket
//Parameter:        char *host
//**************************************
bool ConnectToServer(SOCKET *serverSocket, char *host) {//代理访问server
    printf(&quot;代理ID：%d，代理正在访问目的主机\n&quot;, GetCurrentThreadId());
    sockaddr_in serverAddr;
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(HTTP_PORT);
    //struct hostent
    //{
    //  char* h_name;
    //  char** h_aliases;
    //  short h_addrtype;
    //  short h_length;
    //  char** h_addr_list;
    //};
    //  hostent-&gt;h_name
    //  表示的是主机的规范名。例如www.google.com的规范名其实是www.l.google.com。
    //  hostent-&gt;h_aliases
    //  表示的是主机的别名.www.google.com就是google他自己的别名。有的时候，有的主机可能有好几个别名，这些，其实都是为了易于用户记忆而为自己的网站多取的名字。
    //  hostent-&gt;h_addrtype
    //  表示的是主机ip地址的类型，到底是ipv4(AF_INET)，还是pv6(AF_INET6)
    //  hostent-&gt;h_length
    //  表示的是主机ip地址的长度
    //  hostent-&gt;h_addr_list
    //  表示的是主机的ip地址，注意，这个是以网络字节序存储的。千万不要直接用printf带%s参数来打这个东西，会有问题的哇。所以到真正需要打印出这个IP的话，需要调用inet_ntop()。
    HOSTENT *hostent = gethostbyname(host);//获取主机名字、地址信息
    if (!hostent) {
        printf(&quot;线程ID:%d，gethostbyname没有能够成功获取主机信息\n&quot;, GetCurrentThreadId());
        return false;
    }
    in_addr Inaddr = *((in_addr*)*(hostent-&gt;h_addr_list));
    serverAddr.sin_addr.s_addr = inet_addr(inet_ntoa(Inaddr));
    printf(&quot;主机的IP地址：%s\n&quot;, inet_ntoa(Inaddr));
    *serverSocket = socket(AF_INET, SOCK_STREAM, 0);//创建和远程主机相连的一个socket
    if (*serverSocket == INVALID_SOCKET) {
        return false;
    }
    if (connect(*serverSocket, (SOCKADDR*)&amp;serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) {
        //尝试连接,失败就关闭连接
        closesocket(*serverSocket);
        printf(&quot;线程ID:%d，代理访问目标主机失败\n&quot;, GetCurrentThreadId());
        return false;
    }
    return true;
}
</code></pre>

        </div>


        <aside>
          

          <div class="section share">
            <a href="http://www.facebook.com/sharer.php?src=bm&u=http%3a%2f%2fjingyihiter.github.io%2fpost%2ffirst%2f&t=my%20first%20blog" onclick="window.open(this.href, 'PCwindow', 'width=550, height=350, menubar=no, toolbar=no, scrollbars=yes'); return false;"><i class="fa fa-facebook"></i></a>
            <a href="http://twitter.com/intent/tweet?url=http%3a%2f%2fjingyihiter.github.io%2fpost%2ffirst%2f&text=my%20first%20blog&tw_p=tweetbutton" onclick="window.open(this.href, 'PCwindow', 'width=550, height=350, menubar=no, toolbar=no, scrollbars=yes'); return false;"><i class="fa fa-twitter"></i></a>
            <a href="https://plus.google.com/share?url=http%3a%2f%2fjingyihiter.github.io%2fpost%2ffirst%2f" onclick="window.open(this.href, 'PCwindow', 'width=550, height=350, menubar=no, toolbar=no, scrollbars=yes'); return false;"><i class="fa fa-google-plus"></i></a>
            <a href="http://getpocket.com/edit?url=http%3a%2f%2fjingyihiter.github.io%2fpost%2ffirst%2f&title=my%20first%20blog" onclick="window.open(this.href, 'PCwindow', 'width=550, height=350, menubar=no, toolbar=no, scrollbars=yes'); return false;"><i class="fa fa-get-pocket"></i></a>
          </div>

          
          
          <div class="section">
            <div id="disqus_thread"></div>
            <script type="text/javascript">
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  var disqus_shortname = 'jingyi';
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
            </script>
            <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
            <a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
          </div>
          
          
        </aside>

      </article>

    </div>
    <div class="col-md-4">
      
<aside class="site">

  <div class="panel panel-default">
    <div class="panel-heading">
      <h2 class="panel-title">LatestPosts</h2>
    </div>
    <div class="list-group">
      
      <a href="http://jingyihiter.github.io/contact/" class="list-group-item">contact</a>
      
      <a href="http://jingyihiter.github.io/about/" class="list-group-item">about me</a>
      
      <a href="http://jingyihiter.github.io/post/second/" class="list-group-item">second blog</a>
      
      <a href="http://jingyihiter.github.io/post/first/" class="list-group-item">my first blog</a>
      
    </div>
  </div>

  
  <div class="panel panel-default">
    <div class="panel-heading">
      <h2 class="panel-title">category</h2>
    </div>
    <div class="list-group">
      
    </div>
  </div>
  
  <div class="panel panel-default">
    <div class="panel-heading">
      <h2 class="panel-title">tag</h2>
    </div>
    <div class="list-group">
      
    </div>
  </div>
  

</aside>


    </div>
  </div>

</div>

      </div>
    </div>

    <footer class="site">
      <div class="container">
        <p>Copyright (c) 2015 - 2016, @jingyihiter; all rights reserved.</p>
        <p>Powered by <a href="http://jingyihiter.github.io" target="_blank" rel="nofollow">JingYi</a>, Theme <a href="https://github.com/dim0627/hugo_theme_beg" target="_blank" rel="nofollow">beg</a> designed by <a href="http://yet.unresolved.xyz" target="_blank" rel="nofollow">Daisuke Tsuji</a></p>
      </div>
    </footer>

    <script src="//code.jquery.com/jquery-2.2.1.min.js"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    

  </body>
</html>

