<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>jingyihiter 博客</title>
    <link>http://jingyihiter.github.io/</link>
    <description>Recent content on jingyihiter 博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright (c) 2015 - 2016, @jingyihiter; all rights reserved.</copyright>
    <lastBuildDate>Sun, 15 May 2016 22:45:26 +0800</lastBuildDate>
    <atom:link href="http://jingyihiter.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>contact</title>
      <link>http://jingyihiter.github.io/contact/</link>
      <pubDate>Sun, 15 May 2016 22:45:26 +0800</pubDate>
      
      <guid>http://jingyihiter.github.io/contact/</guid>
      <description>

&lt;h2 id=&#34;contact-me:3c4864f00d23f7ea35511ec930ce1d9c&#34;&gt;contact me&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/jingyihiter&#34;&gt;github&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://twitter.com/jingyihiter&#34;&gt;Twitter&lt;/a&gt;&lt;br&gt;
[QQ](&amp;ldquo;920236875&amp;rdquo;)&lt;br&gt;
[Emial](&amp;ldquo;jingyihiter@gmail.com&amp;rdquo;)&lt;br&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>about me</title>
      <link>http://jingyihiter.github.io/about/</link>
      <pubDate>Sun, 15 May 2016 21:43:37 +0800</pubDate>
      
      <guid>http://jingyihiter.github.io/about/</guid>
      <description>

&lt;h1 id=&#34;me-jingyihiter:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;me:jingyihiter&lt;/h1&gt;

&lt;h2 id=&#34;from-harbin-institute-of-technology:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;from:Harbin Institute of Technology&lt;/h2&gt;

&lt;p&gt;email:jingyihiter@gmail.com&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>second blog</title>
      <link>http://jingyihiter.github.io/post/second/</link>
      <pubDate>Sun, 15 May 2016 21:42:25 +0800</pubDate>
      
      <guid>http://jingyihiter.github.io/post/second/</guid>
      <description></description>
    </item>
    
    <item>
      <title>my first blog</title>
      <link>http://jingyihiter.github.io/post/first/</link>
      <pubDate>Sun, 15 May 2016 21:38:16 +0800</pubDate>
      
      <guid>http://jingyihiter.github.io/post/first/</guid>
      <description>

&lt;h1 id=&#34;my-first-blog:e8fb9c67eba912c72729806db31eaa1b&#34;&gt;my first blog&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/jingyihiter/jingyihiter.github.io/tree/master/images/dog.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;view-code:e8fb9c67eba912c72729806db31eaa1b&#34;&gt;view code&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;Windows.h&amp;gt;
#include &amp;lt;process.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;tchar.h&amp;gt;

#pragma comment(lib,&amp;quot;Ws2_32.lib&amp;quot;)
#define MAXSIZE 65507 //发送数据报文的最大长度
#define HTTP_PORT 80 //http服务器端口

//Http 重要头部数据
struct HttpHeader{
    char method[4]; // POST或者GET，注意有些伪CONNECT，本实验暂不考虑
    char url[1024]; // 请求的url
    char host[1024]; // 目标主机
    char cookie[1024 * 10]; //cookie
    HttpHeader(){
        ZeroMemory(this, sizeof(HttpHeader));
    }
};

// HttpCache 缓存中的数据
struct HttpCache{
    char url[1024];
    char host[1024];
    char last_modified[200];
    char status[4];
    char buffer[MAXSIZE];
    HttpCache(){
        ZeroMemory(this, sizeof(HttpCache));
    }
};

//cache中使用到的参数
HttpCache Cache[1024];
int cached_number = 0;//已经缓存的url数
int last_cache = 0;//上一次缓存的索引

//代理相关参数
SOCKET ProxyServer;
sockaddr_in ProxyServerAddr;
const int ProxyPort = 12345;

//网站过滤用到的参数
char acl[1024][1024];//访问控制表
int acl_number = 0;//已经过滤的网站数

//用户过滤用到的参数
char doa_ip[1024][17];//禁止访问的用户的IP,deny of access
int ip_number = 0;//已经禁止的用户数

//钓鱼网站用到的网页
char fishing_host[1024][1024];//钓鱼的网站，都重定向到today.hit.edu.cn
int host_number = 0; //钓鱼的网站数

//由于新的连接都使用新线程进行处理，对线程的频繁的创建和销毁特别浪费资源
//可以使用线程池技术提高服务器效率
//const int ProxyThreadMaxNum = 20;
//HANDLE ProxyThreadHandle[ProxyThreadMaxNum] = {0};
//DWORD ProxyThreadDW[ProxyThreadMaxNum] = {0};
struct ProxyParam{
    SOCKET clientSocket;
    SOCKET serverSocket;
};

bool InitSocket();
int ParseHttpHead(char *buffer, HttpHeader *httpHeader);
bool ConnectToServer(SOCKET *serverSocket, char *host);
unsigned int __stdcall ProxyThread(LPVOID lpParameter);
void ParseCache(char *buffer, char *status, char* last_modified);

int _tmain(int argc, _TCHAR* argv[]){
    printf(&amp;quot;代理服务器正在启动\n&amp;quot;);
    printf(&amp;quot;初始化...\n&amp;quot;);
    if (!InitSocket()){
        printf(&amp;quot;socket 初始化失败\n&amp;quot;);
        return -1;
    }
    printf(&amp;quot;代理服务器正在运行，监听端口 %d\n&amp;quot;, ProxyPort);
    SOCKET acceptSocket = INVALID_SOCKET;
    SOCKADDR_IN acceptAddr;
    ProxyParam *lpProxyParam;
    HANDLE hThread;
    DWORD dwThreadID;
    char user_ip[16];
    //代理服务器不断监听
    while (true){
        acceptSocket = accept(ProxyServer, (sockaddr*)&amp;amp;acceptAddr, NULL);//在代理服务器上创建新的socket(acceptSocket)与客户通信
        printf(&amp;quot;用户的IP：%s\n&amp;quot;, inet_ntoa(acceptAddr.sin_addr));
        memcpy(user_ip, inet_ntoa(acceptAddr.sin_addr), 16);

        //用户过滤
        for (int i = 0; i &amp;lt; ip_number; i++){
            if (strcmp(user_ip, doa_ip[i]) == 0){
                printf(&amp;quot;用户:%s被禁止访问\n&amp;quot;, user_ip);
                printf(&amp;quot;套接字关闭\n&amp;quot;);
                closesocket(acceptSocket);
                continue;
            }
        }

        lpProxyParam = new ProxyParam;
        if (lpProxyParam == NULL){
            continue;
        }
        lpProxyParam-&amp;gt;clientSocket = acceptSocket;//acceptSocket作为与客户端连接的socket
        hThread = (HANDLE)_beginthreadex(NULL, 0, &amp;amp;ProxyThread, (LPVOID)lpProxyParam, 0, 0);
        //不调用CloseHandle的话会造成内存泄漏
        CloseHandle(hThread);
        Sleep(200);
    }
    closesocket(ProxyServer);
    WSACleanup();
    return 0;
}

//************************************
// Method:    InitSocket
// FullName:  InitSocket
// Access:    public
// Returns:   BOOL
// Qualifier: 初始化套接字
//************************************
bool InitSocket(){
    //加载套接字库（必须）
    WORD wVersionRequested;
    WSADATA wsaData;
    //套接字加载时错误提示
    int err;
    //版本 2.2
    wVersionRequested = MAKEWORD(2, 2);
    //加载 dll 文件 Scoket 库,第一个参数是请求的Socket版本，第二个参数返回请求的Socket的版本信息。
    //第一个参数的高位字节指明副版本、低位字节指明主版本
    //当一个应用程序调用WSAStartup函数时，操作系统根据请求的Socket版本来搜索相应的Socket库，
    //然后绑定找到的Socket库到该应用程序中。
    //以后应用程序就可以调用所请求的Socket库中的其它Socket函数了。
    err = WSAStartup(wVersionRequested, &amp;amp;wsaData);
    if (err != 0){
        //找不到 winsock.dll
        printf(&amp;quot;加载 winsock 失败，错误代码为: %d\n&amp;quot;, WSAGetLastError());
        return FALSE;
    }
    //高位字节指明副版本、低位字节指明主版本
    if (LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 2) {
        printf(&amp;quot;不能找到正确的 winsock 版本\n&amp;quot;);
        WSACleanup();//终止Winsock 2 DLL (Ws2_32.dll)的使用.
        return false;
    }
    //在windows中的Winsock2.h中，
    //#define AF_INET 0
    //#define PF_INET AF_INET
    //所以在windows中AF_INET与PF_INET完全一样.
    //socket函数用于创建socket
    /**/
    //问题1：ProxyServer这个socket是创建在哪的？
    //创建在本地的
    /**/
    ProxyServer = socket(AF_INET, SOCK_STREAM, 0);
    if (INVALID_SOCKET == ProxyServer) {
        printf(&amp;quot;创建套接字失败，错误代码为: %d\n&amp;quot;, WSAGetLastError());
        return false;
    }
    ProxyServerAddr.sin_family = AF_INET;//地址族
    ProxyServerAddr.sin_port = htons(ProxyPort);//端口号，htons:本地字节顺序-&amp;gt;网络字节顺序16bits
    //sin_addr的结构是in_addr
    //struct in_addr
    //{
    //  union
    //  {
    //      struct
    //      {
    //          u_char s_b1, s_b2, s_b3, s_b4;
    //      } S_un_b; //An IPv4 address formatted as four u_chars.
    //      struct
    //      {
    //          u_short s_w1, s_w2;
    //      } S_un_w; //An IPv4 address formatted as two u_shorts
    //      u_long S_addr;//An IPv4 address formatted as a u_long
    //  } S_un;
    //  #define s_addr S_un.S_addr
    //};
    ProxyServerAddr.sin_addr.S_un.S_addr = INADDR_ANY;
    //注意第二个参数的强制转换
    if (bind(ProxyServer, (SOCKADDR*)&amp;amp;ProxyServerAddr, sizeof(SOCKADDR)) == SOCKET_ERROR) {
        printf(&amp;quot;绑定套接字失败\n&amp;quot;);
        return false;
    }
    //SOMAXCONN是最大连接个数，如果设置为 SOMAXCONN，套接字 s 的底层服务提供者将设置 backlog 为最大合理值。
    if (listen(ProxyServer, SOMAXCONN) == SOCKET_ERROR) {
        printf(&amp;quot;监听端口%d 失败&amp;quot;, ProxyPort);
        return false;
    }
    //初始化ACL
    //memcpy(acl[acl_number++], &amp;quot;today.hit.edu.cn&amp;quot;, 17);

    //初始化禁止的用户
    //memcpy(doa_ip[ip_number++], &amp;quot;204.204.204.204&amp;quot;, 16);

    //初始化引导网站
    memcpy(fishing_host[host_number++], &amp;quot;www.sougou.com&amp;quot;, 15);
    return true;
}

//*************************
//Method: ProxyThread
//FullName: ProxyThread
//Access: public
//Returns: unsigned int __stdcall
//Qualifier: 线程执行函数
//Parameter: LPVOID lpParameter
//*************************
unsigned int __stdcall ProxyThread(LPVOID lpParameter) {
    printf(&amp;quot;正在执行代理的线程ID:%d\n&amp;quot;, GetCurrentThreadId());
    char Buffer[MAXSIZE];
    char *CacheBuffer;
    ZeroMemory(Buffer, MAXSIZE);
    SOCKADDR_IN clientAddr;
    int length = sizeof(SOCKADDR_IN);
    int recvSize;
    int ret;

    //从客户端的socket处接受数据
    recvSize = recv(((ProxyParam*)lpParameter)-&amp;gt;clientSocket, Buffer, MAXSIZE, 0);

    if (recvSize &amp;lt;= 0) {
        goto error;
    }

    //解析HTTP报文头
    HttpHeader* httpHeader = new HttpHeader();
    CacheBuffer = new char[recvSize + 1];
    ZeroMemory(CacheBuffer, recvSize + 1);
    memcpy(CacheBuffer, Buffer, recvSize);
    int is_cached = ParseHttpHead(CacheBuffer, httpHeader);
    delete CacheBuffer;

    //执行网站过滤
    for (int i = 0; i &amp;lt; acl_number; i++){
        if (strcmp(httpHeader-&amp;gt;host, acl[i]) == 0){
            printf(&amp;quot;线程ID:%d，禁止访问%s\n&amp;quot;, GetCurrentThreadId(), httpHeader-&amp;gt;host);
            goto error;
        }
    }

    //执行网站引导
    for (int i = 0; i &amp;lt; host_number; i++){
        if (strcmp(httpHeader-&amp;gt;host, fishing_host[i]) == 0){
            printf(&amp;quot;线程ID:%d，网站%s已被重定向\n&amp;quot;, GetCurrentThreadId(), httpHeader-&amp;gt;host);
            //构造302的报文
            char fishing_buffer[MAXSIZE];
            ZeroMemory(fishing_buffer, MAXSIZE);
            char* pr;

            int fishing_len = strlen(&amp;quot;HTTP/1.1 302 Moved Temporarily\r\n&amp;quot;);
            memcpy(fishing_buffer, &amp;quot;HTTP/1.1 302 Moved Temporarily\r\n&amp;quot;, fishing_len);
            pr = fishing_buffer + fishing_len;

            fishing_len = strlen(&amp;quot;Connection:keep-alive\r\n&amp;quot;);
            memcpy(pr, &amp;quot;Connection:keep-alive\r\n&amp;quot;, fishing_len);
            pr = pr + fishing_len;

            fishing_len = strlen(&amp;quot;Cache-Control:max-age=0\r\n&amp;quot;);
            memcpy(pr, &amp;quot;Cache-Control:max-age=0\r\n&amp;quot;, fishing_len);
            pr = pr + fishing_len;

            fishing_len = strlen(&amp;quot;Location: http://today.hit.edu.cn/\r\n\r\n&amp;quot;);
            memcpy(pr, &amp;quot;Location: http://today.hit.edu.cn/\r\n\r\n&amp;quot;, fishing_len);

            //将302报文返回给客户端
            printf(&amp;quot;线程ID:%d，代理正将302报文发送给客户端\n&amp;quot;, GetCurrentThreadId());
            ret = send(((ProxyParam*)lpParameter)-&amp;gt;clientSocket, fishing_buffer, sizeof(fishing_buffer), 0);
            goto error;
        }
    }

    //代理服务器去连接主机httpHeader-&amp;gt;host，并把建立连接的socket保存到((ProxyParam*)lpParameter)-&amp;gt;serverSocket
    if (!ConnectToServer(&amp;amp;((ProxyParam*)lpParameter)-&amp;gt;serverSocket, httpHeader-&amp;gt;host)) {
        goto error;
    }
    printf(&amp;quot;线程ID:%d，代理连接主机 %s 成功\n&amp;quot;, GetCurrentThreadId(), httpHeader-&amp;gt;host);

    //根据是否有缓存分成两种情况
    if (is_cached){//客户端请求的页面已经缓存
        printf(&amp;quot;线程ID:%d, 正在向主机请求缓存\n&amp;quot;, GetCurrentThreadId());
        char cached_buffer[MAXSIZE];
        ZeroMemory(cached_buffer, MAXSIZE);
        memcpy(cached_buffer, Buffer, recvSize);

        //构造缓存的报文头
        char* pr = cached_buffer + recvSize;
        memcpy(pr, &amp;quot;If-modified-since: &amp;quot;, 19);
        pr += 19;
        int lenth = strlen(Cache[last_cache].last_modified);
        memcpy(pr, Cache[last_cache].last_modified, lenth);
        pr += lenth;

        //将客户端发送的 HTTP 数据报文直接转发给目标服务器
        ret = send(((ProxyParam *)lpParameter)-&amp;gt;serverSocket, cached_buffer, strlen(cached_buffer) + 1, 0);
        //等待目标服务器返回数据
        recvSize = recv(((ProxyParam *)lpParameter)-&amp;gt;serverSocket, cached_buffer, MAXSIZE, 0);
        if (recvSize &amp;lt;= 0) {
            goto error;
        }

        //解析包含缓存信息的HTTP报文头
        CacheBuffer = new char[recvSize + 1];
        ZeroMemory(CacheBuffer, recvSize + 1);
        memcpy(CacheBuffer, cached_buffer, recvSize);
        char last_status[4];//用于记录主机返回的状态字
        char last_modified[30];//用于记录记住返回的页面修改的时间
        ParseCache(CacheBuffer, last_status, last_modified);
        delete CacheBuffer;

        //分析cache的状态字
        if (strcmp(last_status, &amp;quot;304&amp;quot;) == 0){//没有被修改
            printf(&amp;quot;线程ID:%d，页面没有修改过,缓存的url为:%s\n&amp;quot;, GetCurrentThreadId(), Cache[last_cache].url);
            //将缓存的数据直接转发给客户端
            printf(&amp;quot;线程ID:%d，代理正在转发数据\n&amp;quot;, GetCurrentThreadId());
            ret = send(((ProxyParam*)lpParameter)-&amp;gt;clientSocket, Cache[last_cache].buffer, sizeof(Cache[last_cache].buffer), 0);
        }
        else if (strcmp(last_status, &amp;quot;200&amp;quot;) == 0){//已经修改了
            //修改缓存中的内容
            printf(&amp;quot;线程ID:%d，页面被修改过,缓存的url为:%s\n&amp;quot;, GetCurrentThreadId(), Cache[last_cache].url);
            memcpy(Cache[last_cache].buffer, cached_buffer, strlen(cached_buffer));
            memcpy(Cache[last_cache].last_modified, last_modified, strlen(last_modified));

            //将目标服务器返回的数据直接转发给客户端
            printf(&amp;quot;线程ID:%d，代理正在转发数据\n&amp;quot;, GetCurrentThreadId());
            ret = send(((ProxyParam*)lpParameter)-&amp;gt;clientSocket, cached_buffer, sizeof(cached_buffer), 0);
        }
    }
    else{//没有缓存过这个页面
        ret = send(((ProxyParam *)lpParameter)-&amp;gt;serverSocket, Buffer, strlen(Buffer)+ 1, 0);
        //等待目标服务器返回数据
        recvSize = recv(((ProxyParam*)lpParameter)-&amp;gt;serverSocket, Buffer, MAXSIZE, 0);

        memcpy(Cache[last_cache].buffer, Buffer, recvSize);//将页面的数据缓存
        printf(&amp;quot;线程ID为：%d,正在缓存的url是：%s\n&amp;quot;, GetCurrentThreadId(), Cache[last_cache].url);

        //将目标服务器返回的数据直接转发给客户端
        printf(&amp;quot;线程ID:%d，代理正在转发数据\n&amp;quot;, GetCurrentThreadId());
        ret = send(((ProxyParam*)lpParameter)-&amp;gt;clientSocket, Buffer, sizeof(Buffer), 0);
    }
    //错误处理、完成转发
error:
    //问题2：为什么不是直接就把套接字关闭，而是将这个线程挂起？
    printf(&amp;quot;线程ID为：%d结束，关闭套接字\n&amp;quot;, GetCurrentThreadId());
    Sleep(200);
    closesocket(((ProxyParam*)lpParameter)-&amp;gt;clientSocket);
    closesocket(((ProxyParam*)lpParameter)-&amp;gt;serverSocket);
    delete lpParameter;
    //msdn上面说线程作为_beginthreadex参数传递的例程中返回时，会自动调用 _endthreadex
    //_endthreadex(0);
    return 0;
}

//*************************
//Method: ParseHttpHead
//FullName: ParseHttpHead
//Access: public
//Returns: void
//Qualifier: 解析 TCP 报文中的 HTTP 头部
//Parameter: char *buffer
//Parameter: HttpHeader *httpHeader
//*************************
int ParseHttpHead(char *buffer, HttpHeader *httpHeader) {
    int flag = 0;//用于表示Cache是否命中，命中为1，不命中为0
    printf(&amp;quot;代理ID：%d, 正在解析Http的头部\n&amp;quot;, GetCurrentThreadId());
    char *p;
    char *ptr;
    const char *delim = &amp;quot;\r\n&amp;quot;;//回车换行符
    //在第一次调用时，strtok_s()必需给予参数s字符串，往后的调用则将参数s设置成NULL。每次调用成功则返回指向被分割出片段的指针。
    p = strtok_s(buffer, delim, &amp;amp;ptr);//提取第一行,strtok_s是分割字符串的函数，ptr中存储缓冲块中下一个将被读取的单词的位置
    printf(&amp;quot;第一行：%s\n&amp;quot;, p);

    if (p[0] == &#39;G&#39;) {  //GET方式
        memcpy(httpHeader-&amp;gt;method, &amp;quot;GET&amp;quot;, 3);
        memcpy(httpHeader-&amp;gt;url, &amp;amp;p[4], strlen(p) - 13);//3(get)+8(http/1.1)+2(get后面和http前面的两个空格)
        printf(&amp;quot;url：%s\n&amp;quot;, httpHeader-&amp;gt;url);//url
        //cache处理
        for (int i = 0; i &amp;lt; 1024; i++){//搜索cache，看当前访问的url是否已经存在cache中了
            if (strcmp(Cache[i].url, httpHeader-&amp;gt;url) == 0){//说明url在cache中已经存在
                flag = 1;
                break;
            }
        }
        if (!flag &amp;amp;&amp;amp; cached_number != 1023){//说明url没有在cache且cache没有满, 把这个url直接存进去
            memcpy(Cache[cached_number].url, &amp;amp;p[4], strlen(p) - 13);//这个地方不加cached_number，在后面修改了host之后再加
            last_cache = cached_number;
        }
        else if (!flag &amp;amp;&amp;amp; cached_number == 1023){//说明url没有在cache且cache满了,把第一个cache覆盖
            memcpy(Cache[0].url, &amp;amp;p[4], strlen(p) - 13);
            last_cache = 0;
        }
    }
    else if (p[0] == &#39;P&#39;) { //POST方式
        memcpy(httpHeader-&amp;gt;method, &amp;quot;POST&amp;quot;, 4);
        memcpy(httpHeader-&amp;gt;url, &amp;amp;p[5], strlen(p) - 14);//4(post)+8(http/1.1)+2(post后面和http前面的两个空格)
        printf(&amp;quot;url：%s\n&amp;quot;, httpHeader-&amp;gt;url);//url
        //cache处理
        for (int i = 0; i &amp;lt; 1024; i++){
            if (strcmp(Cache[i].url, httpHeader-&amp;gt;url) == 0){//说明url在cache中已经存在
                flag = 1;
                break;
            }
        }
        if (!flag &amp;amp;&amp;amp; cached_number != 1023){//说明url没有在cache且cache没有满, 把这个url直接存进去
            memcpy(Cache[cached_number].url, &amp;amp;p[5], strlen(p) - 14);
            last_cache = cached_number;
        }
        else if (!flag &amp;amp;&amp;amp; cached_number == 1023){//说明url没有在cache且cache满了,把第一个cache覆盖
            memcpy(Cache[0].url, &amp;amp;p[4], strlen(p) - 13);
            last_cache = 0;
        }
    }

    p = strtok_s(NULL, delim, &amp;amp;ptr);//使用换行符分割，提取当前行
    while (p) {
        switch (p[0]) {
        case &#39;H&#39;://HOST
            memcpy(httpHeader-&amp;gt;host, &amp;amp;p[6], strlen(p) - 6);//删除host: (这里有一个空格)，共6个字符
            if (!flag &amp;amp;&amp;amp; cached_number != 1023){//把host字段加入到cache中
                memcpy(Cache[last_cache].host, &amp;amp;p[6], strlen(p) - 6);
                cached_number++;
            }
            else if (!flag &amp;amp;&amp;amp; cached_number == 1023){
                memcpy(Cache[last_cache].host, &amp;amp;p[6], strlen(p) - 6);
            }
            break;
        case &#39;C&#39;://Cookie
            if (strlen(p) &amp;gt; 8) {
                char header[8];
                ZeroMemory(header, sizeof(header));
                memcpy(header, p, 6);
                if (!strcmp(header, &amp;quot;Cookie&amp;quot;)) {
                    memcpy(httpHeader-&amp;gt;cookie, &amp;amp;p[8], strlen(p) - 8);
                }
            }
            break;
        //case &#39;&#39;:
        default:
            break;
        }
        p = strtok_s(NULL, delim, &amp;amp;ptr);//使用换行符分割，提取当前行
    }
    return flag;
}

//*************************
//Method: ParseCache
//FullName: ParseCache
//Access: public
//Returns: void
//Qualifier: 解析 TCP 报文中的 HTTP 头部,在已经cache命中的时候使用
//Parameter: char *buffer
//Parameter: HttpHeader *httpHeader
//*************************
void ParseCache(char *buffer, char *status, char* last_modified){
    char *p;
    char *ptr;
    const char * delim = &amp;quot;\r\n&amp;quot;;
    p = strtok_s(buffer, delim, &amp;amp;ptr);//提取第一行
    printf(&amp;quot;缓存的第一行：%s\n&amp;quot;, p);
    memcpy(status, &amp;amp;p[9], 3);
    status[3] = &#39;\0&#39;;
    p = strtok_s(NULL, delim, &amp;amp;ptr);
    while (p){
        if (strstr(p, &amp;quot;Last-Modified&amp;quot;) != NULL){
            memcpy(last_modified, &amp;amp;p[15], strlen(p) - 15);
            break;
        }
        p = strtok_s(NULL, delim, &amp;amp;ptr);
    }
}

//**************************************
//Method:           ConnectToServer
//FullName:         ConnectToServer
//Access:           public
//Returns:          bool
//Qualifier:        根据主机创建目标服务器套接字，并连接
//Parameter:        SOCKET *serverSocket
//Parameter:        char *host
//**************************************
bool ConnectToServer(SOCKET *serverSocket, char *host) {//代理访问server
    printf(&amp;quot;代理ID：%d，代理正在访问目的主机\n&amp;quot;, GetCurrentThreadId());
    sockaddr_in serverAddr;
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(HTTP_PORT);
    //struct hostent
    //{
    //  char* h_name;
    //  char** h_aliases;
    //  short h_addrtype;
    //  short h_length;
    //  char** h_addr_list;
    //};
    //  hostent-&amp;gt;h_name
    //  表示的是主机的规范名。例如www.google.com的规范名其实是www.l.google.com。
    //  hostent-&amp;gt;h_aliases
    //  表示的是主机的别名.www.google.com就是google他自己的别名。有的时候，有的主机可能有好几个别名，这些，其实都是为了易于用户记忆而为自己的网站多取的名字。
    //  hostent-&amp;gt;h_addrtype
    //  表示的是主机ip地址的类型，到底是ipv4(AF_INET)，还是pv6(AF_INET6)
    //  hostent-&amp;gt;h_length
    //  表示的是主机ip地址的长度
    //  hostent-&amp;gt;h_addr_list
    //  表示的是主机的ip地址，注意，这个是以网络字节序存储的。千万不要直接用printf带%s参数来打这个东西，会有问题的哇。所以到真正需要打印出这个IP的话，需要调用inet_ntop()。
    HOSTENT *hostent = gethostbyname(host);//获取主机名字、地址信息
    if (!hostent) {
        printf(&amp;quot;线程ID:%d，gethostbyname没有能够成功获取主机信息\n&amp;quot;, GetCurrentThreadId());
        return false;
    }
    in_addr Inaddr = *((in_addr*)*(hostent-&amp;gt;h_addr_list));
    serverAddr.sin_addr.s_addr = inet_addr(inet_ntoa(Inaddr));
    printf(&amp;quot;主机的IP地址：%s\n&amp;quot;, inet_ntoa(Inaddr));
    *serverSocket = socket(AF_INET, SOCK_STREAM, 0);//创建和远程主机相连的一个socket
    if (*serverSocket == INVALID_SOCKET) {
        return false;
    }
    if (connect(*serverSocket, (SOCKADDR*)&amp;amp;serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) {
        //尝试连接,失败就关闭连接
        closesocket(*serverSocket);
        printf(&amp;quot;线程ID:%d，代理访问目标主机失败\n&amp;quot;, GetCurrentThreadId());
        return false;
    }
    return true;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
